// generated by ModelGongGraphFileTemplate
package models

func IsStaged[Type Gongstruct](stage *StageStruct, instance *Type) (ok bool) {

	switch target := any(instance).(type) {
	// insertion point for stage
	case *Bar:
		ok = stage.IsStagedBar(target)

	case *Key:
		ok = stage.IsStagedKey(target)

	case *Pie:
		ok = stage.IsStagedPie(target)

	case *Scatter:
		ok = stage.IsStagedScatter(target)

	case *Serie:
		ok = stage.IsStagedSerie(target)

	case *Value:
		ok = stage.IsStagedValue(target)

	}
	return
}

// insertion point for stage per struct
	func (stage *StageStruct) IsStagedBar(bar *Bar) (ok bool) {

		_, ok = stage.Bars[bar]
	
		return
	}

	func (stage *StageStruct) IsStagedKey(key *Key) (ok bool) {

		_, ok = stage.Keys[key]
	
		return
	}

	func (stage *StageStruct) IsStagedPie(pie *Pie) (ok bool) {

		_, ok = stage.Pies[pie]
	
		return
	}

	func (stage *StageStruct) IsStagedScatter(scatter *Scatter) (ok bool) {

		_, ok = stage.Scatters[scatter]
	
		return
	}

	func (stage *StageStruct) IsStagedSerie(serie *Serie) (ok bool) {

		_, ok = stage.Series[serie]
	
		return
	}

	func (stage *StageStruct) IsStagedValue(value *Value) (ok bool) {

		_, ok = stage.Values[value]
	
		return
	}


// StageBranch stages instance and apply StageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func StageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for stage branch
	case *Bar:
		stage.StageBranchBar(target)

	case *Key:
		stage.StageBranchKey(target)

	case *Pie:
		stage.StageBranchPie(target)

	case *Scatter:
		stage.StageBranchScatter(target)

	case *Serie:
		stage.StageBranchSerie(target)

	case *Value:
		stage.StageBranchValue(target)

	}
}

// insertion point for stage branch per struct
func (stage *StageStruct) StageBranchBar(bar *Bar) {

	// check if instance is already staged
	if IsStaged(stage, bar) {
		return
	}

	bar.Stage()

	//insertion point for the staging of instances referenced by pointers
	if bar.X != nil {
		StageBranch(stage, bar.X)
	}
	if bar.Y != nil {
		StageBranch(stage, bar.Y)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _serie := range bar.Set {
		StageBranch(stage, _serie)
	}

}

func (stage *StageStruct) StageBranchKey(key *Key) {

	// check if instance is already staged
	if IsStaged(stage, key) {
		return
	}

	key.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) StageBranchPie(pie *Pie) {

	// check if instance is already staged
	if IsStaged(stage, pie) {
		return
	}

	pie.Stage()

	//insertion point for the staging of instances referenced by pointers
	if pie.X != nil {
		StageBranch(stage, pie.X)
	}
	if pie.Y != nil {
		StageBranch(stage, pie.Y)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _serie := range pie.Set {
		StageBranch(stage, _serie)
	}

}

func (stage *StageStruct) StageBranchScatter(scatter *Scatter) {

	// check if instance is already staged
	if IsStaged(stage, scatter) {
		return
	}

	scatter.Stage()

	//insertion point for the staging of instances referenced by pointers
	if scatter.X != nil {
		StageBranch(stage, scatter.X)
	}
	if scatter.Y != nil {
		StageBranch(stage, scatter.Y)
	}
	if scatter.Text != nil {
		StageBranch(stage, scatter.Text)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _serie := range scatter.Set {
		StageBranch(stage, _serie)
	}

}

func (stage *StageStruct) StageBranchSerie(serie *Serie) {

	// check if instance is already staged
	if IsStaged(stage, serie) {
		return
	}

	serie.Stage()

	//insertion point for the staging of instances referenced by pointers
	if serie.Key != nil {
		StageBranch(stage, serie.Key)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _value := range serie.Values {
		StageBranch(stage, _value)
	}

}

func (stage *StageStruct) StageBranchValue(value *Value) {

	// check if instance is already staged
	if IsStaged(stage, value) {
		return
	}

	value.Stage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}


// UnstageBranch stages instance and apply UnstageBranch on all gongstruct instances that are
// referenced by pointers or slices of pointers of the insance
//
// the algorithm stops along the course of graph if a vertex is already staged
func UnstageBranch[Type Gongstruct](stage *StageStruct, instance *Type) {

	switch target := any(instance).(type) {
	// insertion point for unstage branch
	case *Bar:
		stage.UnstageBranchBar(target)

	case *Key:
		stage.UnstageBranchKey(target)

	case *Pie:
		stage.UnstageBranchPie(target)

	case *Scatter:
		stage.UnstageBranchScatter(target)

	case *Serie:
		stage.UnstageBranchSerie(target)

	case *Value:
		stage.UnstageBranchValue(target)

	}
}

// insertion point for unstage branch per struct
func (stage *StageStruct) UnstageBranchBar(bar *Bar) {

	// check if instance is already staged
	if ! IsStaged(stage, bar) {
		return
	}

	bar.Unstage()

	//insertion point for the staging of instances referenced by pointers
	if bar.X != nil {
		UnstageBranch(stage, bar.X)
	}
	if bar.Y != nil {
		UnstageBranch(stage, bar.Y)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _serie := range bar.Set {
		UnstageBranch(stage, _serie)
	}

}

func (stage *StageStruct) UnstageBranchKey(key *Key) {

	// check if instance is already staged
	if ! IsStaged(stage, key) {
		return
	}

	key.Unstage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

func (stage *StageStruct) UnstageBranchPie(pie *Pie) {

	// check if instance is already staged
	if ! IsStaged(stage, pie) {
		return
	}

	pie.Unstage()

	//insertion point for the staging of instances referenced by pointers
	if pie.X != nil {
		UnstageBranch(stage, pie.X)
	}
	if pie.Y != nil {
		UnstageBranch(stage, pie.Y)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _serie := range pie.Set {
		UnstageBranch(stage, _serie)
	}

}

func (stage *StageStruct) UnstageBranchScatter(scatter *Scatter) {

	// check if instance is already staged
	if ! IsStaged(stage, scatter) {
		return
	}

	scatter.Unstage()

	//insertion point for the staging of instances referenced by pointers
	if scatter.X != nil {
		UnstageBranch(stage, scatter.X)
	}
	if scatter.Y != nil {
		UnstageBranch(stage, scatter.Y)
	}
	if scatter.Text != nil {
		UnstageBranch(stage, scatter.Text)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _serie := range scatter.Set {
		UnstageBranch(stage, _serie)
	}

}

func (stage *StageStruct) UnstageBranchSerie(serie *Serie) {

	// check if instance is already staged
	if ! IsStaged(stage, serie) {
		return
	}

	serie.Unstage()

	//insertion point for the staging of instances referenced by pointers
	if serie.Key != nil {
		UnstageBranch(stage, serie.Key)
	}

	//insertion point for the staging of instances referenced by slice of pointers
	for _, _value := range serie.Values {
		UnstageBranch(stage, _value)
	}

}

func (stage *StageStruct) UnstageBranchValue(value *Value) {

	// check if instance is already staged
	if ! IsStaged(stage, value) {
		return
	}

	value.Unstage()

	//insertion point for the staging of instances referenced by pointers

	//insertion point for the staging of instances referenced by slice of pointers

}

